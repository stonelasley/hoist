<!--
Sync Impact Report
===================
Version change: 1.0.0 → 1.1.0 (MINOR — new principle VIII added,
Technology & Architecture Constraints materially expanded)
Modified principles:
  - IV: "API-First with Minimal APIs" → renamed to
    "API-First with Minimal APIs" (unchanged, but scope note added
    clarifying it governs the backend only)
Added sections:
  - Principle VIII: Mobile-First with Expo React Native
  - Technology & Architecture Constraints → Mobile Client subsection
Removed sections: None
Templates requiring updates:
  - .specify/templates/plan-template.md ✅ no changes needed (generic)
  - .specify/templates/spec-template.md ✅ no changes needed (generic)
  - .specify/templates/tasks-template.md ✅ no changes needed (generic)
  - .specify/templates/checklist-template.md ✅ no changes needed (generic)
  - .specify/templates/agent-file-template.md ✅ no changes needed (generic)
Follow-up TODOs: None
-->

# Hoist Constitution

## Core Principles

### I. Clean Architecture

All **backend** code MUST follow the established Clean Architecture
layer boundaries. Dependencies flow inward only:
`Web → Application + Infrastructure → Domain`.

- Domain layer MUST have zero framework dependencies
  (MediatR.Contracts is the sole exception).
- Application layer defines interfaces; Infrastructure implements them.
- Web layer is the composition root and MUST NOT contain business logic.
- New features MUST be organized by feature folder in the Application
  layer (e.g., `Workouts/Commands/LogWorkout/`).

### II. CQRS via MediatR

Every user-facing **backend** operation MUST be expressed as a Command
(write) or Query (read) handled through the MediatR pipeline.

- Commands return the created entity's identifier or nothing.
- Queries return DTOs or view models — never domain entities.
- Cross-cutting concerns (auth, validation, logging, performance) are
  handled exclusively by pipeline behaviors — not in endpoint code.
- New validators MUST use FluentValidation and be auto-discovered.

### III. Domain-Driven Design

Domain entities encapsulate business rules. State changes that matter
to the business MUST raise domain events.

- Entities extend `BaseAuditableEntity` for automatic audit fields.
- Value objects extend `ValueObject` for structural equality.
- Domain events are dispatched after `SaveChanges` via the
  `DispatchDomainEventsInterceptor` — never manually published.

### IV. API-First with Minimal APIs

All HTTP endpoints MUST use the Minimal API pattern via
`EndpointGroupBase` subclasses, auto-discovered and mounted at
`/api/{GroupName}`.

- Endpoints delegate to MediatR — no inline business logic.
- Authorization MUST be declared per-endpoint via `.RequireAuthorization()`
  and per-command/query via the `[Authorize]` attribute.
- OpenAPI spec is auto-generated by NSwag at build time.
- The mobile client (`src/App`) consumes this API — endpoint
  contracts MUST remain stable or be versioned.

### V. Test-Driven Quality

Every feature MUST have corresponding tests. The project uses a
three-tier testing strategy:

- **Unit tests** for domain logic and application handlers (mocked DB).
- **Functional tests** for end-to-end API flows using
  `CustomWebApplicationFactory` with Testcontainers SQL Server.
- **Integration tests** for infrastructure concerns against real DB.
- Tests use NUnit, Shouldly for assertions, Moq for mocking, and
  Respawn for database cleanup between tests.

### VI. Fitness Domain Integrity

Hoist is a workout tracking application. All features MUST serve the
core user journey: plan, track, and share workouts, exercises,
progress pictures, and stats.

- Exercise data MUST be accurate and follow established fitness
  taxonomy (muscle groups, movement patterns, equipment types).
- Workout history is append-only from the user's perspective — edits
  create new versions, never silently overwrite.
- User progress data (body measurements, PRs, photos) MUST be treated
  as private by default. Sharing requires explicit user action.

### VII. Simplicity and YAGNI

Start with the simplest solution that satisfies the requirement.
Complexity MUST be justified.

- No speculative abstractions. Three similar lines of code are better
  than a premature generic helper.
- No feature flags or backwards-compatibility shims when direct code
  changes suffice.
- New NuGet packages MUST be added to `Directory.Packages.props` with
  centrally managed versions.
- New npm packages for the mobile client MUST be Expo-compatible and
  added to `src/App/package.json`.

### VIII. Mobile-First with Expo React Native

The user-facing client is an Expo React Native application located at
`src/App/`. All mobile UI work MUST follow Expo conventions and
leverage the Expo managed workflow.

- Navigation MUST use Expo Router (file-based routing in `app/`).
  New screens are created as files/directories under `src/App/app/`.
- Components MUST be functional React components using hooks.
  Class components are not permitted.
- Platform-specific code MUST use the `.ios.tsx` / `.android.tsx` /
  `.web.tsx` file extension convention (not runtime `Platform.OS`
  branching) when the difference is non-trivial.
- Theming MUST use the centralized `constants/theme.ts` color and
  font tokens. Hard-coded color/font values in components are
  prohibited.
- The mobile client MUST NOT contain business logic — it is a
  presentation layer that delegates to the backend API.
- New Expo SDK features (camera, haptics, etc.) MUST be added via
  the Expo plugin system configured in `app.json`.

## Technology & Architecture Constraints

**Backend Runtime**: .NET 10.0 with C# (nullable reference types,
implicit usings enabled). `TreatWarningsAsErrors` is globally
enforced.

**Database**: SQL Server via Entity Framework Core 10.0. Connection
string key is `HoistDb`. Development uses .NET Aspire to orchestrate
a SQL Server Docker container. Tests use Testcontainers.

**Authentication**: ASP.NET Core Identity with bearer token auth.
Identity endpoints are auto-mapped via `AddApiEndpoints()`.

**Package Management (Backend)**: Central Package Management via
`Directory.Packages.props`. All version variables defined there.

**Build Artifacts**: Output to `artifacts/` directory (configured via
`ArtifactsPath` in `Directory.Build.props`).

**Orchestration**: .NET Aspire AppHost (`src/AppHost`) for local
development. `dotnet run --project src/AppHost` is the standard
backend development entry point.

**Mobile Client**: Expo SDK 54 with React Native 0.81, React 19,
and TypeScript 5.9. The app lives at `src/App/` and uses
expo-router 6 for file-based navigation. New Architecture is
enabled (`newArchEnabled: true`). The React Compiler experiment
is active.

**Mobile Dependencies**: React Navigation 7 (bottom tabs),
react-native-reanimated 4, react-native-gesture-handler 2,
react-native-screens 4, expo-image, expo-haptics.

**Mobile Dev Server**: `npx expo start` from `src/App/`. Platform
targets: iOS (supports tablet), Android (edge-to-edge, adaptive
icon), and Web (static output).

**Linting (Mobile)**: ESLint 9 with `eslint-config-expo`.

## Development Workflow

**Feature Development**: New features follow the SpecKit workflow —
specify → clarify → plan → tasks → implement. Feature specs live in
`specs/{number}-{feature-name}/`.

**Branching**: Feature branches use the pattern `{number}-{feature-name}`
matching the specs directory.

**Code Scaffolding (Backend)**: Use the Clean Architecture template
for new commands and queries:
`dotnet new ca-usecase --name CreateFoo --feature-name Foos --usecase-type command --return-type int`

**Database Changes**: EF Core entity configurations live in
`src/Infrastructure/Data/Configurations/`. In development, the DB is
dropped and recreated on startup via `ApplicationDbContextInitialiser`.

**API Documentation**: NSwag generates the OpenAPI spec at build time.
Swagger UI is available at `/api` in development.

**Mobile Development**: Run `npx expo start` from `src/App/` to
launch the Expo dev server. Use Expo Go or a development build for
on-device testing. New screens are added as `.tsx` files under
`src/App/app/`.

## Governance

This constitution supersedes ad-hoc decisions. All feature specs,
implementation plans, and code reviews MUST verify compliance with
these principles.

- **Amendments** require documentation of the change, rationale, and
  a version bump following semantic versioning (MAJOR for principle
  removal/redefinition, MINOR for additions, PATCH for clarifications).
- **Violations** MUST be documented in the plan's Complexity Tracking
  table with justification and rejected simpler alternatives.
- **Compliance review** occurs during `/speckit.analyze` and code review.

**Version**: 1.1.0 | **Ratified**: 2026-02-07 | **Last Amended**: 2026-02-14
