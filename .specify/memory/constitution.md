<!--
Sync Impact Report
===================
Version change: 0.0.0 → 1.0.0 (initial ratification)
Modified principles: N/A (all new)
Added sections:
  - Core Principles (I–VII)
  - Technology & Architecture Constraints
  - Development Workflow
  - Governance
Removed sections: N/A
Templates requiring updates:
  - .specify/templates/plan-template.md ✅ no changes needed (generic)
  - .specify/templates/spec-template.md ✅ no changes needed (generic)
  - .specify/templates/tasks-template.md ✅ no changes needed (generic)
  - .specify/templates/checklist-template.md ✅ no changes needed (generic)
  - .specify/templates/agent-file-template.md ✅ no changes needed (generic)
Follow-up TODOs: None
-->

# Hoist Constitution

## Core Principles

### I. Clean Architecture

All code MUST follow the established Clean Architecture layer
boundaries. Dependencies flow inward only:
`Web → Application + Infrastructure → Domain`.

- Domain layer MUST have zero framework dependencies
  (MediatR.Contracts is the sole exception).
- Application layer defines interfaces; Infrastructure implements them.
- Web layer is the composition root and MUST NOT contain business logic.
- New features MUST be organized by feature folder in the Application
  layer (e.g., `Workouts/Commands/LogWorkout/`).

### II. CQRS via MediatR

Every user-facing operation MUST be expressed as a Command (write) or
Query (read) handled through the MediatR pipeline.

- Commands return the created entity's identifier or nothing.
- Queries return DTOs or view models — never domain entities.
- Cross-cutting concerns (auth, validation, logging, performance) are
  handled exclusively by pipeline behaviors — not in endpoint code.
- New validators MUST use FluentValidation and be auto-discovered.

### III. Domain-Driven Design

Domain entities encapsulate business rules. State changes that matter
to the business MUST raise domain events.

- Entities extend `BaseAuditableEntity` for automatic audit fields.
- Value objects extend `ValueObject` for structural equality.
- Domain events are dispatched after `SaveChanges` via the
  `DispatchDomainEventsInterceptor` — never manually published.

### IV. API-First with Minimal APIs

All HTTP endpoints MUST use the Minimal API pattern via
`EndpointGroupBase` subclasses, auto-discovered and mounted at
`/api/{GroupName}`.

- Endpoints delegate to MediatR — no inline business logic.
- Authorization MUST be declared per-endpoint via `.RequireAuthorization()`
  and per-command/query via the `[Authorize]` attribute.
- OpenAPI spec is auto-generated by NSwag at build time.

### V. Test-Driven Quality

Every feature MUST have corresponding tests. The project uses a
three-tier testing strategy:

- **Unit tests** for domain logic and application handlers (mocked DB).
- **Functional tests** for end-to-end API flows using
  `CustomWebApplicationFactory` with Testcontainers SQL Server.
- **Integration tests** for infrastructure concerns against real DB.
- Tests use NUnit, Shouldly for assertions, Moq for mocking, and
  Respawn for database cleanup between tests.

### VI. Fitness Domain Integrity

Hoist is a workout tracking application. All features MUST serve the
core user journey: plan, track, and share workouts, exercises,
progress pictures, and stats.

- Exercise data MUST be accurate and follow established fitness
  taxonomy (muscle groups, movement patterns, equipment types).
- Workout history is append-only from the user's perspective — edits
  create new versions, never silently overwrite.
- User progress data (body measurements, PRs, photos) MUST be treated
  as private by default. Sharing requires explicit user action.

### VII. Simplicity and YAGNI

Start with the simplest solution that satisfies the requirement.
Complexity MUST be justified.

- No speculative abstractions. Three similar lines of code are better
  than a premature generic helper.
- No feature flags or backwards-compatibility shims when direct code
  changes suffice.
- New NuGet packages MUST be added to `Directory.Packages.props` with
  centrally managed versions.

## Technology & Architecture Constraints

**Runtime**: .NET 10.0 with C# (nullable reference types, implicit
usings enabled). `TreatWarningsAsErrors` is globally enforced.

**Database**: SQL Server via Entity Framework Core 10.0. Connection
string key is `HoistDb`. Development uses .NET Aspire to orchestrate
a SQL Server Docker container. Tests use Testcontainers.

**Authentication**: ASP.NET Core Identity with bearer token auth.
Identity endpoints are auto-mapped via `AddApiEndpoints()`.

**Package Management**: Central Package Management via
`Directory.Packages.props`. All version variables defined there.

**Build Artifacts**: Output to `artifacts/` directory (configured via
`ArtifactsPath` in `Directory.Build.props`).

**Orchestration**: .NET Aspire AppHost (`src/AppHost`) for local
development. `dotnet run --project src/AppHost` is the standard
development entry point.

## Development Workflow

**Feature Development**: New features follow the SpecKit workflow —
specify → clarify → plan → tasks → implement. Feature specs live in
`specs/{number}-{feature-name}/`.

**Branching**: Feature branches use the pattern `{number}-{feature-name}`
matching the specs directory.

**Code Scaffolding**: Use the Clean Architecture template for new
commands and queries:
`dotnet new ca-usecase --name CreateFoo --feature-name Foos --usecase-type command --return-type int`

**Database Changes**: EF Core entity configurations live in
`src/Infrastructure/Data/Configurations/`. In development, the DB is
dropped and recreated on startup via `ApplicationDbContextInitialiser`.

**API Documentation**: NSwag generates the OpenAPI spec at build time.
Swagger UI is available at `/api` in development.

## Governance

This constitution supersedes ad-hoc decisions. All feature specs,
implementation plans, and code reviews MUST verify compliance with
these principles.

- **Amendments** require documentation of the change, rationale, and
  a version bump following semantic versioning (MAJOR for principle
  removal/redefinition, MINOR for additions, PATCH for clarifications).
- **Violations** MUST be documented in the plan's Complexity Tracking
  table with justification and rejected simpler alternatives.
- **Compliance review** occurs during `/speckit.analyze` and code review.

**Version**: 1.0.0 | **Ratified**: 2026-02-07 | **Last Amended**: 2026-02-07
